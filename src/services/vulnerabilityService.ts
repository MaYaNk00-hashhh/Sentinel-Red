import type { Vulnerability, VulnerabilityFilter } from '@/types/vulnerability'
import apiClient from '@/lib/api'
import type { AttackGraph } from '@/types/attackGraph'

// Cache for vulnerabilities to avoid repeated fetches
let vulnerabilityCache: { data: Vulnerability[], timestamp: number } | null = null
const CACHE_TTL = 60000 // 1 minute cache

export const vulnerabilityService = {
  // Clear the cache (useful after new scans)
  clearCache() {
    vulnerabilityCache = null
  },

  async getVulnerabilities(filters?: VulnerabilityFilter, scanId?: string): Promise<Vulnerability[]> {
    try {
      // Check cache first (only for unfiltered requests without specific scanId)
      if (!scanId && !filters?.scanId && vulnerabilityCache && (Date.now() - vulnerabilityCache.timestamp < CACHE_TTL)) {
        let cached = vulnerabilityCache.data
        // Apply filters to cached data
        if (filters?.severity) {
          cached = cached.filter(v => v.severity === filters.severity)
        }
        if (filters?.type) {
          cached = cached.filter(v => v.type === filters.type)
        }
        return cached
      }

      let scanIds: string[] = []
      let projectMap: Map<string, { name: string, id: string }> = new Map()

      if (scanId) {
        scanIds = [scanId]
      } else {
        // Fetch all projects to get all scans (including historical)
        const { data: projects } = await apiClient.get<any[]>('/projects')

        if (!projects || projects.length === 0) {
          return []
        }

        // Create project map for later reference
        projects.forEach((p: any) => {
          projectMap.set(p.id, { name: p.name, id: p.id })
        })

        // Collect ALL scan IDs from all projects (not just last_scan_id)
        // First, get the last scan IDs
        const lastScanIds = projects
          .filter((p: any) => p.last_scan_id && p.last_scan_status === 'completed')
          .map((p: any) => ({ scanId: p.last_scan_id, projectId: p.id, projectName: p.name }))

        // Also fetch scan history for each project to get historical scans
        const historyPromises = projects.map(async (p: any) => {
          try {
            const { data: history } = await apiClient.get<any>(`/projects/${p.id}/history`)
            const scans = Array.isArray(history) ? history : (history?.data || [])
            return scans
              .filter((s: any) => s.status === 'completed' && s.id)
              .map((s: any) => ({ scanId: s.id, projectId: p.id, projectName: p.name, startedAt: s.started_at }))
          } catch {
            return []
          }
        })

        const historicalScans = (await Promise.all(historyPromises)).flat()

        // Combine and deduplicate scan IDs
        const allScans = [...lastScanIds, ...historicalScans]
        const uniqueScans = Array.from(
          new Map(allScans.map(s => [s.scanId, s])).values()
        )

        scanIds = uniqueScans.map(s => s.scanId)

        // Update project map with scan info
        uniqueScans.forEach(s => {
          if (!projectMap.has(s.projectId)) {
            projectMap.set(s.projectId, { name: s.projectName, id: s.projectId })
          }
        })
      }

      if (scanIds.length === 0) return []

      // Fetch attack graphs for all scans in parallel (with concurrency limit)
      const BATCH_SIZE = 5
      let allVulnerabilities: Vulnerability[] = []

      for (let i = 0; i < scanIds.length; i += BATCH_SIZE) {
        const batch = scanIds.slice(i, i + BATCH_SIZE)
        const graphPromises = batch.map(id =>
          apiClient.get<AttackGraph>(`/attack-graph/${id}`, { timeout: 10000 })
            .then(res => ({ id, data: res.data }))
            .catch(() => null) // Ignore failed fetches
        )

        const graphs = await Promise.all(graphPromises)

        for (const graphResult of graphs) {
          if (!graphResult || !graphResult.data) continue

          const graph = graphResult.data
          const vulnNodes = graph.nodes?.filter((n: any) => n.type === 'vulnerability') || []

          // Get project info for this scan
          const projectInfo = graph.project_id ? projectMap.get(graph.project_id) : null

          const scanVulns: Vulnerability[] = vulnNodes.map((node: any) => ({
            id: `${graphResult.id}-${node.id}`, // Unique ID combining scan and node
            scan_id: graph.scan_id || graphResult.id,
            project_name: projectInfo?.name || graph.project_name || 'Unknown Project',
            project_id: projectInfo?.id || graph.project_id,
            title: node.label || 'Unknown Vulnerability',
            description: node.data?.description || 'No description available.',
            severity: (node.data?.severity as any) || 'medium',
            type: mapVulnerabilityType(node.label, node.data?.category),
            impact: getImpactDescription(node.data?.severity),
            exploit_complexity: getExploitComplexity(node.data?.severity),
            cvss_score: getCVSSScore(node.data?.severity),
            affected_endpoints: node.data?.endpoint ? [node.data.endpoint] : [],
            discovered_at: graph.metadata?.scanDate || graph.created_at || new Date().toISOString(),
            recommended_fixes: node.data?.recommendation ? [node.data.recommendation] : ['Review code logic and implement security best practices'],
            attack_chain: [],
            evidence: node.data?.request ? {
              request: {
                method: node.data.request.method,
                url: node.data.request.url,
                headers: node.data.request.headers || {},
                body: node.data.request.body
              },
              response: {
                status: node.data.response?.status || 0,
                headers: node.data.response?.headers || {},
                body: node.data.response?.body
              }
            } : undefined
          }))

          allVulnerabilities = [...allVulnerabilities, ...scanVulns]
        }
      }

      // Sort by severity (critical first) and then by date (newest first)
      allVulnerabilities.sort((a, b) => {
        const severityOrder = { critical: 0, high: 1, medium: 2, low: 3, info: 4 }
        const severityDiff = (severityOrder[a.severity] || 4) - (severityOrder[b.severity] || 4)
        if (severityDiff !== 0) return severityDiff
        return new Date(b.discovered_at).getTime() - new Date(a.discovered_at).getTime()
      })

      // Cache the unfiltered results
      if (!scanId && !filters?.scanId) {
        vulnerabilityCache = { data: allVulnerabilities, timestamp: Date.now() }
      }

      // Apply Client-side Filters
      if (filters?.severity) {
        allVulnerabilities = allVulnerabilities.filter(v => v.severity === filters.severity)
      }
      if (filters?.type) {
        allVulnerabilities = allVulnerabilities.filter(v => v.type === filters.type)
      }

      return allVulnerabilities
    } catch (error) {
      console.error('Failed to fetch vulnerabilities:', error)
      return []
    }
  },

  async getVulnerability(id: string): Promise<Vulnerability> {
    const all = await this.getVulnerabilities()
    const found = all.find(v => v.id === id)
    if (!found) throw new Error('Vulnerability not found')
    return found
  },
}

// Helper functions
function mapVulnerabilityType(label?: string, category?: string): Vulnerability['type'] {
  const text = (label || category || '').toLowerCase()
  if (text.includes('idor') || text.includes('access')) return 'IDOR'
  if (text.includes('auth')) return 'Auth Bypass'
  if (text.includes('injection') || text.includes('xss') || text.includes('validation')) return 'Input Validation'
  if (text.includes('logic')) return 'Business Logic'
  if (text.includes('bypass')) return 'Logic Bypass'
  return 'Other'
}

function getImpactDescription(severity?: string): string {
  switch (severity) {
    case 'critical': return 'Complete system compromise, data breach, or service disruption'
    case 'high': return 'Significant security risk with potential for data exposure'
    case 'medium': return 'Moderate security concern requiring attention'
    case 'low': return 'Minor security issue with limited impact'
    default: return 'Security concern requiring review'
  }
}

function getExploitComplexity(severity?: string): 'low' | 'medium' | 'high' {
  switch (severity) {
    case 'critical': return 'low'
    case 'high': return 'low'
    case 'medium': return 'medium'
    case 'low': return 'high'
    default: return 'medium'
  }
}

function getCVSSScore(severity?: string): number {
  switch (severity) {
    case 'critical': return 9.5
    case 'high': return 7.5
    case 'medium': return 5.0
    case 'low': return 2.5
    default: return 5.0
  }
}
