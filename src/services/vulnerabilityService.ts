import type { Vulnerability, VulnerabilityFilter } from '@/types/vulnerability'
import apiClient from '@/lib/api'
import type { AttackGraph } from '@/types/attackGraph'

export const vulnerabilityService = {
  async getVulnerabilities(filters?: VulnerabilityFilter, scanId?: string): Promise<Vulnerability[]> {
    try {
      let scanIds: string[] = [];

      if (scanId) {
        scanIds = [scanId];
      } else {
        // Fetch all projects to get all recent scans
        const { data: projects } = await apiClient.get<any[]>('/projects');

        if (!projects || projects.length === 0) {
          return [];
        }

        // Collect all completed scan IDs
        scanIds = projects
          .filter((p: any) => p.last_scan_id && p.last_scan_status === 'completed')
          .map((p: any) => p.last_scan_id);
      }

      if (scanIds.length === 0) return [];

      // Fetch metadata for all scans in parallel
      const graphPromises = scanIds.map(id =>
        apiClient.get<AttackGraph>(`/attack-graph/${id}`)
          .then(res => ({ id, data: res.data }))
          .catch(() => null) // Ignore failed fetches
      );

      const graphs = await Promise.all(graphPromises);

      let allVulnerabilities: Vulnerability[] = [];

      for (const graphResult of graphs) {
        if (!graphResult || !graphResult.data) continue;

        const graph = graphResult.data;
        const vulnNodes = graph.nodes.filter((n: any) => n.type === 'vulnerability');

        const scanVulns: Vulnerability[] = vulnNodes.map((node: any) => ({
          id: node.id,
          scan_id: graph.scan_id || graphResult.id, // Fallback to requested ID
          title: node.label || 'Unknown Vulnerability',
          description: node.data.description || 'No description available.',
          severity: (node.data.severity as any) || 'medium',
          type: node.label?.includes('Injection') ? 'Input Validation' :
            node.label?.includes('Auth') ? 'Auth Bypass' :
              node.label?.includes('XSS') ? 'Input Validation' :
                'Logic Bypass',
          impact: 'Potential Security Breach',
          exploit_complexity: 'medium',
          cvss_score: node.data.severity === 'critical' ? 9.8 :
            node.data.severity === 'high' ? 7.5 :
              node.data.severity === 'medium' ? 5.3 : 3.0,
          affected_endpoints: node.data.endpoint ? [node.data.endpoint] : [],
          discovered_at: new Date().toISOString(),
          recommended_fixes: node.data.recommendation ? [node.data.recommendation] : ['Review code logic'],
          attack_chain: [],
          evidence: node.data.request ? {
            request: {
              method: node.data.request.method,
              url: node.data.request.url,
              headers: node.data.request.headers,
              body: node.data.request.body
            },
            response: {
              status: node.data.response?.status || 0,
              headers: node.data.response?.headers || {},
              body: node.data.response?.body
            }
          } : undefined
        }));

        allVulnerabilities = [...allVulnerabilities, ...scanVulns];
      }

      // Apply Client-side Filters
      if (filters?.severity) {
        allVulnerabilities = allVulnerabilities.filter(v => v.severity === filters.severity);
      }
      if (filters?.type) {
        allVulnerabilities = allVulnerabilities.filter(v => v.type === filters.type);
      }

      return allVulnerabilities;
    } catch (error) {
      console.error('Failed to fetch vulnerabilities:', error);
      return [];
    }
  },

  async getVulnerability(id: string): Promise<Vulnerability> {
    // This is inefficient (fetching all), but fine for MVP without dedicated single-vuln endpoint
    const all = await this.getVulnerabilities()
    const found = all.find(v => v.id === id)
    if (!found) throw new Error('Vulnerability not found')
    return found
  },
}
